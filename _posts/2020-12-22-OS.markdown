
---
layout:     post
title:      "操作系统学习笔记"
subtitle:   " 课程来源：清华大学（向勇、陈渝） "
date:       2020-12-22
author:     "Kaylee"
header-img: "img/post-bg-digital-native.jpg"
catalog: true
tags:
    - Study Note
---


## Intro
### kernel-操作系统内部组件，包括：
- CPU调度器
-	物理内存管理
-	虚拟内存管理
-	文件系统管理
-	中断处理与设备驱动

### OS Kernel的特征：
- **并发**
   - 计算机系统中同时存在多个运行的程序，需要OS管理和调度
- **共享**
- ‘同时’访问
   - 互斥共享
- **虚拟**
   - 利用多道程序设计技术，让每个用户都觉得有一个计算机专门为他服务
- **异步**
  - 程序的执行不是一贯到底，而是走走停停，向前推进的速度不可预知
  - 但只要运行环境相同，OS需要保护程序的运行结果也要相同

### 并行和并发的区别：
- 并发：一段时间内有多个程序
- 并行：一个时间点有多个程序一起运行，并行要求计算机内存在多个CPU，如果计算机只有一个CPU无法完成并行

### 学习操作系统
- 顶会： SOSP/USENIX

### 操作系统需要考虑的balance：
- 空间/时间
- 性能和可预测性
- 公平和性能

### 操作系统结构

**微内核：**数据——>内核——>内存管理的子系统。要完成多次拷贝。

**外核：**希望内核分两部分，一部分和硬件打交道，另一部分和具体应用打交道。这两个部分可以安全有效的并发的访问资源。好处是比较快。

**VMM虚拟机监控器：**这个是在传统OS下，虚拟出多个计算机系统，给上层的计算机系统使用。超系统下是VMM，VMM下才是硬件。VMM可以虚拟出多台计算机。有了VMM后一台计算机可以看作多台计算机，一台计算机里有多个CPU存在，可以同时为多人使用。

## 启动、中断、异常和系统调用
### 启动
CPU, I/O, 内存通过总线连接。

**DISK：**存放OS

**BIOS：**基本的I/O处理系统

**Bootloader：**加载OS

当电脑通电时，段寄存器CS和指令寄存器IP能够确定一个内存地址，CS：IP = 0xf000:fff0

**过程：**
- POST加电自检，寻找显卡和执行BIOS
以X86为例，BIOS将bootloader从磁盘的引导扇区加载到0x7c00

- Bootloader将操作系统的代码和数据从硬盘加载到内存中，然后跳转到操作系统的起始地址

**操作系统与设备和程序交互：**
- 系统调用（来源于应用程序）
  - 应用程序主动向OS发出服务请求
- 异常（来源于不良的应用程序）
  -非法指令或者其他坏的处理状态，比如内存出错
- 中断（来源于外设）
  - 来组不同的硬件设备的计时器和网络的中断

在计算机运行中，**内核是被信任的第三方**。只有内核可以执行特权指令。

**产生的源头：**
- 中断：外设(键盘/鼠标/网卡/声卡/显卡，可以产生各种事件)
- 异常：应用程序意想不到的行为(e.g.异常，恶意程序，应用程序需要的资源未得到满足)
- 系统调用(system call)：应用程序请求操作提供服务(e.g.打开/关闭/读写文件，发送网络包)

**处理时间：**
- 中断：异步；
- 异常：同步；
- 系统调用：同步或异步。

**响应：**
- 中断：持续，对用户应用程序时透明的
- 异常：杀死或者重新执行意想不到的应用程序指令
- 系统调用：等待和持续

### 中断/异常和系统调用
**中断/异常处理机制：**
中断是外设的事件，异常是CPU的事件；中断/异常迫使CPU访问一些被中断和异常服务访问的功能。

**中断处理机制**

- 硬件：设置中断标记(CPU初始化)

  - 将内部/外部事件设置中断标记；
  - 中断事件的ID(程序访问的中断向量地址)

- 软件(操作系统)：
  - 保存当前处理状态
  - 中断服务程序处理
  - 清除中断标记
  - 恢复之前保存的处理状态

**异常处理机制**
- 异常：异常编号
  - 保存现场
- 异常处理：杀死产生异常的程序；重新执行异常指令
- 恢复现场

**系统调用**

- 一条指令会触发一个系统调用

- 程序访问主要是通过高层次的API接口而不是直接进行系统调用。

- 通常情况下，存在与每个系统调用相关的序号，系统调用接口根据这些序号来维护表的索引。
- 系统调用接口调用内核态中预期的系统调用，并返回系统调用的状态和其它任何返回值。
- 用户不需要知道系统调用是如何实现的，只需要获取API和了解操作新系统将什么作为返回结果。操作系统接口的细节大部分都隐藏在API中，并通过运行程序支持的库来管理。

- 用户态：应用程序在执行的过程中，CPU执行的特权级的状态(很低，不能访问特殊机器指令和IO)。
- 内核态：应用程序在执行的过程中，CPU执行的特权级的状态(高，操作系统可以执行CPU任何一条指令)。
- 系统调用时涉及到特权级从用户态到内核态的转换，应用程序和操作系统有各自的堆栈，这两个变化比函数调用的开销更大，但更安全和可靠。(而程序调用是在一个栈空间实现参数的调用和返回)。

**跨越操作系统边界的开销**

- 在执行时间上超过程序调用
- 开销包括：
  - 建立中断/异常/系统调用号与对应服务例程映射关系的初始化开销；
  - 建立内核堆栈(操作系统和应用程序的堆栈不一样)；
  - 验证参数(操作系统会检查数据)；
  - 内核态映射到用户态的地址空间，更新页面映射权限(内存拷贝开销)；
  - 内核态独立地址空间TLB
